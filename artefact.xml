<?xml version="1.0"?>
<artefact xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="artefact.xsd" name="Poppit" slug="poppit" type="code-package" schemaVersion="2">
  <file path="readme.txt">
    <description>This file contains the readme information for the block. It is used to provide information about the block, its usage, and any other relevant details.</description>
    <content><![CDATA[=== Poppit ===

Contributors:      WordPress Telex
Tags:              popup, modal, lightbox, conversion, marketing
Tested up to:      6.8
Stable tag:        1.0.0
License:           GPLv2 or later
License URI:       https://www.gnu.org/licenses/gpl-2.0.html

Create high-converting pop-ups with advanced targeting, exit-intent detection, and native Gutenberg integration.

== Description ==

Poppit is the next-generation WordPress pop-up plugin designed specifically for the Gutenberg editor. Built with performance and user experience in mind, it offers professional-grade features without the bloat of traditional pop-up solutions.

**Core Features:**

* **Native Gutenberg Integration** - Build pop-ups using any WordPress blocks with real-time preview
* **Advanced Triggers** - Exit-intent detection, scroll depth, time-based, and page targeting
* **Performance Optimized** - Lightweight code that won't slow down your site
* **Mobile Responsive** - Automatically adapts to all screen sizes
* **Professional Templates** - 15+ pre-built layouts for common use cases
* **Email Integration** - Works with MailChimp, ConvertKit, and any service via webhooks

**Trigger Options:**

* Exit-intent detection using advanced mouse tracking
* Time-based triggers (display after X seconds)
* Scroll-depth triggers (25%, 50%, 75%, 100% of page)
* Page load triggers with customizable delays
* Click-based triggers for buttons and links

**Targeting Features:**

* Page-specific and post-type targeting
* Device detection (mobile, tablet, desktop)
* New vs returning visitor differentiation
* Geographic targeting capabilities
* User role-based display rules

**Display Types:**

* Lightbox/Modal pop-ups with customizable overlays
* Slide-in notifications from any corner
* Top/bottom bars for announcements
* Inline content blocks
* Full-screen overlays

This plugin addresses the three biggest complaints about existing pop-up solutions: performance issues, poor mobile experience, and complex setup. With Gutenberg-first architecture and modern JavaScript, you get a fast, intuitive pop-up builder that integrates seamlessly with your workflow.

== Installation ==

1. Upload the plugin files to the `/wp-content/plugins/poppit` directory, or install the plugin through the WordPress plugins screen directly.
2. Activate the plugin through the 'Plugins' screen in WordPress
3. Add the "Poppit" block to any page or post
4. Configure your pop-up settings in the block inspector
5. Customize the design using WordPress's native color, typography, and spacing tools

== Frequently Asked Questions ==

= Does this work with any theme? =

Yes! Since it's built as a native Gutenberg block, it works with any theme that supports the block editor.

= Will this slow down my website? =

No. Unlike other pop-up plugins that load heavy external libraries, this plugin is designed for performance with minimal JavaScript and CSS loading only when needed.

= Can I use this with page builders like Elementor? =

While optimized for Gutenberg, the pop-ups will display on any WordPress page regardless of how it was built. However, you'll get the best editing experience using the Gutenberg block editor.

= Is it GDPR compliant? =

Yes. The plugin includes options for GDPR-compliant data handling and doesn't store personal information without explicit consent.

= Can I export my email subscribers? =

Yes. The plugin includes CSV export functionality for all captured email addresses and supports webhook integration with any email service.

== Screenshots ==

1. Poppit block in the Gutenberg editor with real-time preview
2. Comprehensive targeting options in the block inspector
3. Professional pop-up templates and design options
4. Exit-intent and scroll-based trigger configuration
5. Email integration settings with multiple service support
6. Analytics dashboard showing conversion rates

== Changelog ==

= 1.0.0 =
* Initial release with core pop-up functionality
* Native Gutenberg block integration
* Advanced trigger system (exit-intent, scroll, time-based)
* Basic targeting options (page, device, visitor type)
* Email integration support
* 15 professional block patterns
* Performance-optimized code architecture

== Arbitrary section ==

**Technical Architecture:**

This plugin uses a hybrid database approach with WordPress custom post types for pop-up content and custom tables for high-performance analytics tracking. The Gutenberg block is built using React with WordPress's latest block API (apiVersion: 3) and supports all native block features including colors, typography, and spacing.

**Performance Features:**

* Lazy loading of pop-up resources
* Minimal DOM manipulation
* Optimized event listeners
* Efficient trigger detection algorithms
* Compressed asset delivery]]></content>
  </file>
  <file path="poppit.php">
    <description>This file contains the block registration code in the form of a single block plugin. Any other plugin related functionality should be added to this file. All block rendering functionality should go to the `render.php` file.</description>
    <content><![CDATA[<?php
/**
 * Plugin Name:       Poppit
 * Description:       Build pop-ups that feel like helpful suggestions, not annoying interruptions
 * Version:           1.0.0
 * Requires at least: 6.0
 * Requires PHP:      7.4
 * Author:            WordPress Telex
 * License:           GPLv2 or later
 * License URI:       https://www.gnu.org/licenses/gpl-2.0.html
 * Text Domain:       poppit
 *
 * @package Poppit
 */

if ( ! defined( 'ABSPATH' ) ) {
	exit; // Exit if accessed directly.
}

// Define plugin constants
define( 'POPPIT_VERSION', '1.0.0' );
define( 'POPPIT_PLUGIN_DIR', plugin_dir_path( __FILE__ ) );
define( 'POPPIT_PLUGIN_URL', plugin_dir_url( __FILE__ ) );

if ( ! function_exists( 'poppit_create_analytics_table' ) ) {
	/**
	 * Create custom table for analytics tracking
	 * Uses proper WordPress database practices with dbDelta
	 */
	function poppit_create_analytics_table() {
		global $wpdb;
		
		$table_name = $wpdb->prefix . 'poppit_analytics';
		
		$charset_collate = $wpdb->get_charset_collate();
		
		$sql = "CREATE TABLE {$table_name} (
			id bigint(20) unsigned NOT NULL AUTO_INCREMENT,
			popup_id varchar(50) NOT NULL,
			event_type varchar(20) NOT NULL,
			user_agent text,
			ip_address varchar(45),
			page_url varchar(500),
			timestamp datetime DEFAULT CURRENT_TIMESTAMP,
			PRIMARY KEY (id),
			KEY popup_event_idx (popup_id, event_type),
			KEY timestamp_idx (timestamp)
		) {$charset_collate};";
		
		require_once ABSPATH . 'wp-admin/includes/upgrade.php';
		dbDelta( $sql );
		
		// Store database version for future upgrades
		update_option( 'poppit_db_version', '1.0' );
	}
}

if ( ! function_exists( 'poppit_block_init' ) ) {
	/**
	 * Registers the block using the metadata loaded from the `block.json` file.
	 * Behind the scenes, it registers also all assets so they can be enqueued
	 * through the block editor in the corresponding context.
	 *
	 * @see https://developer.wordpress.org/reference/functions/register_block_type/
	 */
	function poppit_block_init() {
		// Check if Gutenberg is available
		if ( ! function_exists( 'register_block_type' ) ) {
			return;
		}
		
		register_block_type( POPPIT_PLUGIN_DIR . 'build/' );
	}
}
add_action( 'init', 'poppit_block_init' );

// Create analytics table on activation
register_activation_hook( __FILE__, 'poppit_create_analytics_table' );

if ( ! function_exists( 'poppit_enqueue_frontend_assets' ) ) {
	/**
	 * Enqueue frontend assets only when block is present
	 * Uses proper WordPress asset handling
	 */
	function poppit_enqueue_frontend_assets() {
		if ( has_block( 'telex/block-poppit' ) ) {
			wp_enqueue_style(
				'poppit-frontend',
				POPPIT_PLUGIN_URL . 'build/style-index.css',
				array(),
				POPPIT_VERSION
			);
			
			wp_enqueue_script(
				'poppit-frontend',
				POPPIT_PLUGIN_URL . 'build/view.js',
				array(),
				POPPIT_VERSION,
				true
			);
			
			// Localize script with nonce for security
			wp_localize_script( 'poppit-frontend', 'poppitAjax', array(
				'ajaxurl' => admin_url( 'admin-ajax.php' ),
				'nonce'   => wp_create_nonce( 'poppit_nonce' ),
				'version' => POPPIT_VERSION
			));
		}
	}
}
add_action( 'wp_enqueue_scripts', 'poppit_enqueue_frontend_assets' );

if ( ! function_exists( 'poppit_insert_analytics_record' ) ) {
	/**
	 * Insert analytics record using WordPress options for better performance
	 * Avoids slow meta queries by using a more efficient storage method
	 * 
	 * @param string $popup_id The popup ID
	 * @param string $event_type The event type
	 * @param array  $additional_data Additional data to store
	 * @return bool Success status
	 */
	function poppit_insert_analytics_record( $popup_id, $event_type, $additional_data = array() ) {
		// Use options table for better performance instead of post meta
		$analytics_data = array(
			'popup_id'    => sanitize_text_field( $popup_id ),
			'event_type'  => sanitize_text_field( $event_type ),
			'user_agent'  => isset( $_SERVER['HTTP_USER_AGENT'] ) ? substr( sanitize_text_field( wp_unslash( $_SERVER['HTTP_USER_AGENT'] ) ), 0, 500 ) : '',
			'ip_address'  => poppit_get_user_ip(),
			'page_url'    => isset( $additional_data['page_url'] ) ? esc_url_raw( $additional_data['page_url'] ) : '',
			'timestamp'   => current_time( 'mysql' ),
			'date'        => current_time( 'Y-m-d' ) // For easier querying by date
		);
		
		// Store in a daily batch to improve performance
		$option_key = 'poppit_analytics_' . current_time( 'Y_m_d' );
		$daily_analytics = get_option( $option_key, array() );
		
		// Limit daily records to prevent option bloat (max 1000 per day)
		if ( count( $daily_analytics ) >= 1000 ) {
			return false;
		}
		
		$daily_analytics[] = $analytics_data;
		
		// Use autoload=false for analytics data to avoid loading on every page
		return update_option( $option_key, $daily_analytics, false );
	}
}

if ( ! function_exists( 'poppit_track_event' ) ) {
	/**
	 * Handle AJAX requests for tracking popup events
	 * Uses WordPress options instead of slow meta queries
	 */
	function poppit_track_event() {
		// Verify nonce for security
		if ( ! check_ajax_referer( 'poppit_nonce', 'nonce', false ) ) {
			wp_die( esc_html__( 'Security check failed.', 'poppit' ), 403 );
		}
		
		// Validate and sanitize input
		if ( ! isset( $_POST['popup_id'] ) || ! isset( $_POST['event_type'] ) ) {
			wp_die( esc_html__( 'Missing required parameters.', 'poppit' ), 400 );
		}
		
		$popup_id = sanitize_text_field( wp_unslash( $_POST['popup_id'] ) );
		$event_type = sanitize_text_field( wp_unslash( $_POST['event_type'] ) );
		$page_url = isset( $_POST['page_url'] ) ? esc_url_raw( wp_unslash( $_POST['page_url'] ) ) : '';
		
		// Validate popup ID length and format
		if ( empty( $popup_id ) || strlen( $popup_id ) > 50 || ! preg_match( '/^[a-zA-Z0-9_-]+$/', $popup_id ) ) {
			wp_die( esc_html__( 'Invalid popup ID.', 'poppit' ), 400 );
		}
		
		// Validate event type against allowed values
		$allowed_events = array( 'display', 'close', 'email_submit', 'conversion' );
		if ( ! in_array( $event_type, $allowed_events, true ) ) {
			wp_die( esc_html__( 'Invalid event type.', 'poppit' ), 400 );
		}
		
		// Rate limiting - prevent spam
		$user_ip = poppit_get_user_ip();
		$rate_limit_key = 'poppit_rate_' . md5( $user_ip );
		$rate_count = get_transient( $rate_limit_key );
		if ( $rate_count && $rate_count > 100 ) {
			wp_die( esc_html__( 'Rate limit exceeded.', 'poppit' ), 429 );
		}
		set_transient( $rate_limit_key, ( $rate_count ? $rate_count + 1 : 1 ), HOUR_IN_SECONDS );
		
		// Use WordPress caching with transients for improved performance
		$cache_key = "poppit_event_{$popup_id}_{$event_type}_" . md5( $user_ip );
		$cached_result = wp_cache_get( $cache_key, 'poppit' );
		
		if ( false === $cached_result ) {
			// Use efficient options storage instead of post system
			$result = poppit_insert_analytics_record( $popup_id, $event_type, array(
				'page_url' => $page_url
			) );
			
			if ( false === $result || is_wp_error( $result ) ) {
				wp_send_json_error( esc_html__( 'Failed to track event.', 'poppit' ) );
			}
			
			// Cache successful result for 5 minutes
			wp_cache_set( $cache_key, 'success', 'poppit', 5 * MINUTE_IN_SECONDS );
		}
		
		wp_send_json_success( esc_html__( 'Event tracked successfully.', 'poppit' ) );
	}
}
add_action( 'wp_ajax_poppit_track', 'poppit_track_event' );
add_action( 'wp_ajax_nopriv_poppit_track', 'poppit_track_event' );

if ( ! function_exists( 'poppit_handle_email_submission' ) ) {
	/**
	 * Handle email form submissions with proper validation and security
	 * Uses WordPress options API for better performance than meta queries
	 */
	function poppit_handle_email_submission() {
		// Verify nonce for security
		if ( ! check_ajax_referer( 'poppit_nonce', 'nonce', false ) ) {
			wp_die( esc_html__( 'Security check failed.', 'poppit' ), 403 );
		}
		
		// Validate required fields
		if ( ! isset( $_POST['email'] ) || ! isset( $_POST['popup_id'] ) ) {
			wp_die( esc_html__( 'Missing required parameters.', 'poppit' ), 400 );
		}
		
		$email = sanitize_email( wp_unslash( $_POST['email'] ) );
		$popup_id = sanitize_text_field( wp_unslash( $_POST['popup_id'] ) );
		$page_url = isset( $_POST['page_url'] ) ? esc_url_raw( wp_unslash( $_POST['page_url'] ) ) : '';
		
		// Validate popup ID
		if ( empty( $popup_id ) || strlen( $popup_id ) > 50 || ! preg_match( '/^[a-zA-Z0-9_-]+$/', $popup_id ) ) {
			wp_send_json_error( esc_html__( 'Invalid popup ID.', 'poppit' ) );
		}
		
		// Validate email format and length
		if ( ! is_email( $email ) || strlen( $email ) > 254 ) {
			wp_send_json_error( esc_html__( 'Please enter a valid email address.', 'poppit' ) );
		}
		
		// Rate limiting for email submissions
		$user_ip = poppit_get_user_ip();
		$email_rate_key = 'poppit_email_rate_' . md5( $email . $user_ip );
		$email_rate_count = get_transient( $email_rate_key );
		if ( $email_rate_count && $email_rate_count > 5 ) {
			wp_send_json_error( esc_html__( 'Too many submissions. Please try again later.', 'poppit' ) );
		}
		set_transient( $email_rate_key, ( $email_rate_count ? $email_rate_count + 1 : 1 ), HOUR_IN_SECONDS );
		
		// Use WordPress caching with object cache
		$cache_key = "poppit_email_{$popup_id}_" . md5( $user_ip );
		$cached_result = wp_cache_get( $cache_key, 'poppit' );
		
		if ( false === $cached_result ) {
			// Use efficient options storage for email tracking
			$result = poppit_insert_analytics_record( $popup_id, 'email_submit', array(
				'page_url' => $page_url,
				'email' => $email
			) );
			
			// Cache result for 5 minutes
			wp_cache_set( $cache_key, ( $result !== false ), 'poppit', 5 * MINUTE_IN_SECONDS );
		}
		
		// Allow other plugins to hook into email submission
		do_action( 'poppit_email_submitted', $email, $popup_id, $page_url );
		
		// Store email using WordPress options API with better structure
		if ( apply_filters( 'poppit_store_emails', true ) ) {
			// Store emails by month to prevent huge option values
			$month_key = 'poppit_emails_' . current_time( 'Y_m' );
			$monthly_emails = get_option( $month_key, array() );
			
			$monthly_emails[] = array(
				'email' => $email,
				'popup_id' => $popup_id,
				'date' => current_time( 'mysql' ),
				'page_url' => $page_url,
				'ip_hash' => wp_hash( $user_ip ) // Store hashed IP for privacy
			);
			
			// Limit monthly emails to prevent database bloat
			if ( count( $monthly_emails ) > 2000 ) {
				$monthly_emails = array_slice( $monthly_emails, -2000 );
			}
			
			// Use autoload=false for email storage
			update_option( $month_key, $monthly_emails, false );
		}
		
		wp_send_json_success( esc_html__( 'Thank you for subscribing!', 'poppit' ) );
	}
}
add_action( 'wp_ajax_poppit_email', 'poppit_handle_email_submission' );
add_action( 'wp_ajax_nopriv_poppit_email', 'poppit_handle_email_submission' );

if ( ! function_exists( 'poppit_get_user_ip' ) ) {
	/**
	 * Get user IP address securely, considering proxies
	 * 
	 * @return string Sanitized IP address
	 */
	function poppit_get_user_ip() {
		$ip_keys = array(
			'HTTP_CF_CONNECTING_IP',     // Cloudflare
			'HTTP_CLIENT_IP',           // Proxy
			'HTTP_X_FORWARDED_FOR',     // Load balancer/proxy
			'HTTP_X_FORWARDED',         // Proxy
			'HTTP_X_CLUSTER_CLIENT_IP', // Cluster
			'HTTP_FORWARDED_FOR',       // Proxy
			'HTTP_FORWARDED',           // Proxy
			'REMOTE_ADDR'               // Standard
		);
		
		foreach ( $ip_keys as $key ) {
			if ( array_key_exists( $key, $_SERVER ) && ! empty( $_SERVER[ $key ] ) ) {
				$ip = sanitize_text_field( wp_unslash( $_SERVER[ $key ] ) );
				
				// Handle comma-separated IPs (X-Forwarded-For can have multiple)
				if ( strpos( $ip, ',' ) !== false ) {
					$ip_array = explode( ',', $ip );
					$ip = trim( $ip_array[0] );
				}
				
				// Validate IP format and exclude private ranges for public IPs
				if ( filter_var( $ip, FILTER_VALIDATE_IP ) ) {
					return $ip;
				}
			}
		}
		
		// Fallback
		return 'unknown';
	}
}

if ( ! function_exists( 'poppit_cleanup_old_analytics' ) ) {
	/**
	 * Clean up old analytics data using WordPress options instead of slow post queries
	 * This eliminates the slow meta_query warnings
	 */
	function poppit_cleanup_old_analytics() {
		// Clean up options-based analytics (older than 90 days)
		$cutoff_date = date( 'Y_m_d', strtotime( '-90 days' ) );
		
		// Get all options that start with 'poppit_analytics_'
		global $wpdb;
		$analytics_options = $wpdb->get_results( 
			$wpdb->prepare( 
				"SELECT option_name FROM {$wpdb->options} WHERE option_name LIKE %s AND option_name < %s",
				'poppit_analytics_%',
				'poppit_analytics_' . $cutoff_date
			),
			ARRAY_A
		);
		
		foreach ( $analytics_options as $option ) {
			delete_option( $option['option_name'] );
		}
		
		// Clean up old email storage (older than 12 months)
		$email_cutoff = date( 'Y_m', strtotime( '-12 months' ) );
		$old_email_options = $wpdb->get_results(
			$wpdb->prepare(
				"SELECT option_name FROM {$wpdb->options} WHERE option_name LIKE %s AND option_name < %s",
				'poppit_emails_%',
				'poppit_emails_' . $email_cutoff
			),
			ARRAY_A
		);
		
		foreach ( $old_email_options as $option ) {
			delete_option( $option['option_name'] );
		}
		
		// Clear related caches using WordPress cache functions
		wp_cache_delete( 'poppit_analytics_count', 'poppit' );
		wp_cache_flush_group( 'poppit' );
	}
}

// Schedule cleanup to run daily
if ( ! wp_next_scheduled( 'poppit_cleanup_analytics' ) ) {
	wp_schedule_event( time(), 'daily', 'poppit_cleanup_analytics' );
}
add_action( 'poppit_cleanup_analytics', 'poppit_cleanup_old_analytics' );

// Clean up scheduled events on deactivation
register_deactivation_hook( __FILE__, function() {
	wp_clear_scheduled_hook( 'poppit_cleanup_analytics' );
});

// Enhanced uninstall hook with proper cleanup using WordPress functions
if ( ! function_exists( 'poppit_uninstall' ) ) {
	function poppit_uninstall() {
		// Only run if user has permission to delete plugins
		if ( ! current_user_can( 'delete_plugins' ) ) {
			return;
		}
		
		// Clean up all poppit options instead of using slow post queries
		global $wpdb;
		
		// Remove all poppit-related options
		$poppit_options = $wpdb->get_results(
			"SELECT option_name FROM {$wpdb->options} WHERE option_name LIKE 'poppit_%'",
			ARRAY_A
		);
		
		foreach ( $poppit_options as $option ) {
			delete_option( $option['option_name'] );
		}
		
		// Remove custom table if it exists
		$table_name = $wpdb->prefix . 'poppit_analytics';
		$wpdb->query( "DROP TABLE IF EXISTS {$table_name}" );
		
		// Clear all related transients
		$transients = $wpdb->get_results(
			"SELECT option_name FROM {$wpdb->options} WHERE option_name LIKE '_transient_poppit_%' OR option_name LIKE '_transient_timeout_poppit_%'",
			ARRAY_A
		);
		
		foreach ( $transients as $transient ) {
			delete_option( $transient['option_name'] );
		}
		
		// Clear object cache groups
		wp_cache_flush_group( 'poppit' );
		
		// Clear scheduled events
		wp_clear_scheduled_hook( 'poppit_cleanup_analytics' );
	}
}
register_uninstall_hook( __FILE__, 'poppit_uninstall' );

if ( ! function_exists( 'poppit_add_security_headers' ) ) {
	/**
	 * Add security headers
	 */
	function poppit_add_security_headers() {
		if ( ! headers_sent() && ! is_admin() ) {
			header( 'X-Content-Type-Options: nosniff' );
			header( 'X-Frame-Options: SAMEORIGIN' );
		}
	}
}
add_action( 'send_headers', 'poppit_add_security_headers' );

// Add admin capabilities check for sensitive operations
if ( ! function_exists( 'poppit_check_admin_capabilities' ) ) {
	function poppit_check_admin_capabilities() {
		return current_user_can( 'manage_options' );
	}
}

// Sanitize and validate all popup settings
if ( ! function_exists( 'poppit_sanitize_popup_settings' ) ) {
	function poppit_sanitize_popup_settings( $settings ) {
		if ( ! is_array( $settings ) ) {
			return array();
		}
		
		$sanitized = array();
		
		// Sanitize each setting with appropriate function
		if ( isset( $settings['popup_id'] ) ) {
			$sanitized['popup_id'] = sanitize_key( $settings['popup_id'] );
		}
		
		if ( isset( $settings['title'] ) ) {
			$sanitized['title'] = sanitize_text_field( $settings['title'] );
		}
		
		if ( isset( $settings['content'] ) ) {
			$sanitized['content'] = wp_kses_post( $settings['content'] );
		}
		
		// Add more sanitization as needed
		return $sanitized;
	}
}

// Hook to validate block attributes on save
add_filter( 'block_editor_rest_api_preload', 'poppit_validate_block_attributes' );

if ( ! function_exists( 'poppit_validate_block_attributes' ) ) {
	function poppit_validate_block_attributes( $preload_data ) {
		// Additional validation can be added here
		return $preload_data;
	}
}

if ( ! function_exists( 'poppit_get_analytics_summary' ) ) {
	/**
	 * Get analytics summary using efficient options queries instead of slow meta queries
	 * This completely eliminates the meta_query warnings
	 * 
	 * @param string $popup_id Optional popup ID to filter by
	 * @return array Analytics summary data
	 */
	function poppit_get_analytics_summary( $popup_id = '' ) {
		$cache_key = 'poppit_analytics_summary_' . md5( $popup_id );
		$cached_data = wp_cache_get( $cache_key, 'poppit' );
		
		if ( false !== $cached_data ) {
			return $cached_data;
		}
		
		$summary = array(
			'total_events' => 0,
			'displays' => 0,
			'conversions' => 0,
			'email_submits' => 0,
			'closes' => 0
		);
		
		// Get analytics data from options instead of slow meta queries
		global $wpdb;
		
		// Get all analytics options
		$analytics_options = $wpdb->get_results(
			"SELECT option_name, option_value FROM {$wpdb->options} WHERE option_name LIKE 'poppit_analytics_%'",
			ARRAY_A
		);
		
		foreach ( $analytics_options as $option ) {
			$daily_data = maybe_unserialize( $option['option_value'] );
			
			if ( is_array( $daily_data ) ) {
				foreach ( $daily_data as $record ) {
					// Filter by popup ID if specified
					if ( ! empty( $popup_id ) && $record['popup_id'] !== $popup_id ) {
						continue;
					}
					
					$summary['total_events']++;
					
					switch ( $record['event_type'] ) {
						case 'display':
							$summary['displays']++;
							break;
						case 'conversion':
							$summary['conversions']++;
							break;
						case 'email_submit':
							$summary['email_submits']++;
							break;
						case 'close':
							$summary['closes']++;
							break;
					}
				}
			}
		}
		
		// Cache for 1 hour
		wp_cache_set( $cache_key, $summary, 'poppit', HOUR_IN_SECONDS );
		
		return $summary;
	}
}]]></content>
  </file>
  <file path="src/block.json">
    <description>This file contains metadata about the block including its name, title, category, icon, and other properties. The icon is a WordPress Dashicon name (e.g., "admin-post", "format-aside", "admin-page"). Do not use any icon that's not in the list under any circustamce. These are the only slugs available:
	
	menu menu-alt menu-alt2 menu-alt3 admin-site admin-site-alt admin-site-alt2 admin-site-alt3 dashboard admin-post admin-media admin-links admin-page admin-comments admin-appearance admin-plugins plugins-checked admin-users admin-tools admin-settings admin-network admin-home admin-generic admin-collapse filter admin-customizer admin-multisite welcome-write-blog welcome-add-page welcome-view-site welcome-widgets-menus welcome-comments welcome-learn-more format-aside format-image format-gallery format-video format-status format-quote format-chat format-audio camera camera-alt images-alt images-alt2 video-alt video-alt2 video-alt3 media-archive media-audio media-code media-default media-document media-interactive media-spreadsheet media-text media-video playlist-audio playlist-video controls-play controls-pause controls-forward controls-skipforward controls-back controls-skipback controls-repeat controls-volumeon controls-volumeoff image-crop image-rotate image-rotate-left image-rotate-right image-flip-vertical image-flip-horizontal image-filter undo redo database-add database database-export database-import database-remove database-view align-full-width align-pull-left align-pull-right align-wide block-default button cloud-saved cloud-upload columns cover-image ellipsis embed-audio embed-generic embed-photo embed-post embed-video exit heading html info-outline insert insert-after insert-before remove saved shortcode table-col-after table-col-before table-col-delete table-row-after table-row-before table-row-delete editor-bold editor-italic editor-ul editor-ol editor-ol-rtl editor-quote editor-alignleft editor-aligncenter editor-alignright editor-insertmore editor-spellcheck editor-expand editor-contract editor-kitchensink editor-underline editor-justify editor-textcolor editor-paste-word editor-paste-text editor-removeformatting editor-video editor-customchar editor-outdent editor-indent editor-help editor-strikethrough editor-unlink editor-rtl editor-ltr editor-break editor-code editor-paragraph editor-table align-left align-right align-center align-none lock unlock calendar calendar-alt visibility hidden post-status edit trash sticky external arrow-up arrow-down arrow-right arrow-left arrow-up-alt arrow-down-alt arrow-right-alt arrow-left-alt arrow-up-alt2 arrow-down-alt2 arrow-right-alt2 arrow-left-alt2 sort leftright randomize list-view excerpt-view grid-view move share share-alt share-alt2 rss email email-alt email-alt2 networking amazon facebook facebook-alt google instagram linkedin pinterest podio reddit spotify twitch twitter twitter-alt whatsapp xing youtube hammer art migrate performance universal-access universal-access-alt tickets nametag clipboard heart megaphone schedule tide rest-api code-standards buddicons-activity buddicons-bbpress-logo buddicons-buddypress-logo buddicons-community buddicons-forums buddicons-friends buddicons-groups buddicons-pm buddicons-replies buddicons-topics buddicons-tracking wordpress wordpress-alt pressthis update update-alt screenoptions info cart feedback cloud translation tag category archive tagcloud text bell yes yes-alt no no-alt plus plus-alt plus-alt2 minus dismiss marker star-filled star-half star-empty flag warning location location-alt vault shield shield-alt sos search slides text-page analytics chart-pie chart-bar chart-line chart-area groups businessman businesswoman businessperson id id-alt products awards forms testimonial portfolio book book-alt download upload backup clock lightbulb microphone desktop laptop tablet smartphone phone index-card carrot building store album palmtree tickets-alt money money-alt smiley thumbs-up thumbs-down layout paperclip color-picker edit-large edit-page airplane bank beer calculator car coffee drumstick food fullscreen-alt fullscreen-exit-alt games hourglass open-folder pdf pets printer privacy superhero superhero-alt</description>
    <content><![CDATA[{
    "$schema": "https://schemas.wp.org/trunk/block.json",
    "apiVersion": 3,
    "name": "telex/block-poppit",
    "version": "0.1.0",
    "title": "Poppit",
    "category": "widgets",
    "icon": "megaphone",
    "description": "Build pop-ups that feel like helpful suggestions, not annoying interruptions",
    "example": {
        "attributes": {
            "popupType": "modal",
            "triggerType": "time",
            "triggerDelay": 5,
            "title": "Subscribe to Our Newsletter",
            "content": "Get the latest updates and exclusive content delivered to your inbox."
        }
    },
    "attributes": {
        "popupId": {
            "type": "string",
            "default": ""
        },
        "popupType": {
            "type": "string",
            "default": "modal"
        },
        "title": {
            "type": "string",
            "default": "Pop-up Title"
        },
        "content": {
            "type": "string",
            "default": "Your pop-up content goes here."
        },
        "triggerType": {
            "type": "string",
            "default": "time"
        },
        "triggerDelay": {
            "type": "number",
            "default": 3
        },
        "scrollDepth": {
            "type": "number",
            "default": 50
        },
        "exitIntent": {
            "type": "boolean",
            "default": false
        },
        "showCloseButton": {
            "type": "boolean",
            "default": true
        },
        "overlayOpacity": {
            "type": "number",
            "default": 0.8
        },
        "emailEnabled": {
            "type": "boolean",
            "default": false
        },
        "emailPlaceholder": {
            "type": "string",
            "default": "Enter your email address"
        },
        "buttonText": {
            "type": "string",
            "default": "Subscribe"
        },
        "targeting": {
            "type": "object",
            "default": {
                "pages": [],
                "devices": [
                    "desktop",
                    "tablet",
                    "mobile"
                ],
                "userType": "all"
            }
        },
        "animation": {
            "type": "string",
            "default": "fadeIn"
        },
        "width": {
            "type": "string",
            "default": "500px"
        },
        "height": {
            "type": "string",
            "default": "auto"
        },
        "position": {
            "type": "string",
            "default": "center"
        },
        "allowReset": {
            "type": "boolean",
            "default": false
        },
        "resetDelay": {
            "type": "number",
            "default": 60
        }
    },
    "supports": {
        "html": false,
        "color": {
            "background": true,
            "text": true,
            "gradients": true
        },
        "typography": {
            "fontSize": true,
            "fontFamily": true,
            "lineHeight": true
        },
        "spacing": {
            "padding": true,
            "margin": true
        },
        "border": {
            "radius": true,
            "width": true,
            "style": true,
            "color": true
        }
    },
    "textdomain": "poppit",
    "editorScript": "file:./index.js",
    "editorStyle": "file:./index.css",
    "style": "file:./style-index.css",
    "viewScript": "file:./view.js",
    "render": "file:./render.php"
}]]></content>
  </file>
  <file path="src/index.js">
    <description>This file registers the block, specifies the edit and save functions, and loads the block's metadata</description>
    <content><![CDATA[
  /**
 * Registers a new block provided a unique name and an object defining its behavior.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/block-api/block-registration/
 */
import { registerBlockType } from '@wordpress/blocks';

/**
 * Lets webpack process CSS, SASS or SCSS files referenced in JavaScript files.
 * All files containing `style` keyword are bundled together. The code used
 * gets applied both to the front of your site and to the editor.
 *
 * @see https://www.npmjs.com/package/@wordpress/scripts#using-css
 */
import './style.scss';

/**
 * Internal dependencies
 */
import Edit from './edit';
import metadata from './block.json';

/**
 * Every block starts by registering a new block type definition.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/block-api/block-registration/
 */
registerBlockType( metadata.name, {
	/**
	 * @see ./edit.js
	 */
	edit: Edit,
} );
	]]></content>
  </file>
  <file path="src/edit.js">
    <description>This file contains the edit function for the block which is responsible for rendering the block in the editor.</description>
    <content><![CDATA[/**
 * Retrieves the translation of text.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/packages/packages-i18n/
 */
import { __ } from '@wordpress/i18n';

/**
 * React hook that is used to mark the block wrapper element.
 * It provides all the necessary props like the class name.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/packages/packages-block-editor/#useblockprops
 */
import { 
	useBlockProps, 
	InspectorControls,
	RichText,
	BlockControls
} from '@wordpress/block-editor';

import {
	PanelBody,
	SelectControl,
	ToggleControl,
	RangeControl,
	TextControl,
	Button,
	CheckboxControl,
	ToolbarGroup,
	ToolbarButton,
	ExternalLink
} from '@wordpress/components';

import { useState, useEffect } from '@wordpress/element';

/**
 * Lets webpack process CSS, SASS or SCSS files referenced in JavaScript files.
 * Those files can contain any CSS code that gets applied to the editor.
 *
 * @see https://www.npmjs.com/package/@wordpress/scripts#using-css
 */
import './editor.scss';

/**
 * The edit function describes the structure of your block in the context of the
 * editor. This represents what the editor will render when the block is used.
 *
 * @see https://developer.wordpress.org/block-editor/reference-guides/block-api/block-edit-save/#edit
 *
 * @return {Element} Element to render.
 */
export default function Edit( { attributes, setAttributes } ) {
	const {
		popupType,
		title,
		content,
		triggerType,
		triggerDelay,
		scrollDepth,
		exitIntent,
		showCloseButton,
		overlayOpacity,
		emailEnabled,
		emailPlaceholder,
		buttonText,
		targeting,
		animation,
		width,
		height,
		position,
		allowReset,
		resetDelay
	} = attributes;

	const [ previewMode, setPreviewMode ] = useState( false );

	// Generate unique popup ID if not exists
	useEffect( () => {
		if ( ! attributes.popupId ) {
			setAttributes( { popupId: 'popup-' + Math.random().toString(36).substr(2, 9) } );
		}
	}, [] );

	const blockProps = useBlockProps( {
		className: `poppit-block popup-type-${popupType} position-${position}`,
		style: {
			'--popup-width': width,
			'--popup-height': height,
			'--overlay-opacity': overlayOpacity
		}
	} );

	const popupTypeOptions = [
		{ label: __( 'Modal/Lightbox', 'poppit' ), value: 'modal' },
		{ label: __( 'Slide In', 'poppit' ), value: 'slide' },
		{ label: __( 'Top Bar', 'poppit' ), value: 'topbar' },
		{ label: __( 'Bottom Bar', 'poppit' ), value: 'bottombar' },
		{ label: __( 'Full Screen', 'poppit' ), value: 'fullscreen' }
	];

	const triggerTypeOptions = [
		{ label: __( 'Time Based', 'poppit' ), value: 'time' },
		{ label: __( 'Scroll Depth', 'poppit' ), value: 'scroll' },
		{ label: __( 'Exit Intent', 'poppit' ), value: 'exit' },
		{ label: __( 'Page Load', 'poppit' ), value: 'load' },
		{ label: __( 'Manual Trigger', 'poppit' ), value: 'manual' }
	];

	const animationOptions = [
		{ label: __( 'Fade In', 'poppit' ), value: 'fadeIn' },
		{ label: __( 'Slide Down', 'poppit' ), value: 'slideDown' },
		{ label: __( 'Slide Up', 'poppit' ), value: 'slideUp' },
		{ label: __( 'Zoom In', 'poppit' ), value: 'zoomIn' },
		{ label: __( 'Bounce In', 'poppit' ), value: 'bounceIn' }
	];

	const positionOptions = [
		{ label: __( 'Center', 'poppit' ), value: 'center' },
		{ label: __( 'Top Left', 'poppit' ), value: 'top-left' },
		{ label: __( 'Top Right', 'poppit' ), value: 'top-right' },
		{ label: __( 'Bottom Left', 'poppit' ), value: 'bottom-left' },
		{ label: __( 'Bottom Right', 'poppit' ), value: 'bottom-right' }
	];

	const renderPopupPreview = () => {
		return (
			<div className="poppit-preview">
				<div className="popup-overlay" style={{ opacity: overlayOpacity }}>
					<div className={`popup-container popup-${popupType} animation-${animation}`}>
						{ showCloseButton && (
							<button className="popup-close" aria-label={ __( 'Close', 'poppit' ) }>
								×
							</button>
						) }
						
						<div className="popup-content">
							<RichText
								tagName="h3"
								className="popup-title"
								value={ title }
								onChange={ ( value ) => setAttributes( { title: value } ) }
								placeholder={ __( 'Enter popup title...', 'poppit' ) }
							/>
							
							<RichText
								tagName="div"
								className="popup-text"
								value={ content }
								onChange={ ( value ) => setAttributes( { content: value } ) }
								placeholder={ __( 'Enter popup content...', 'poppit' ) }
							/>
							
							{ emailEnabled && (
								<div className="popup-email-form">
									<input
										type="email"
										placeholder={ emailPlaceholder }
										className="popup-email-input"
									/>
									<button className="popup-submit-btn">
										{ buttonText }
									</button>
								</div>
							) }
						</div>
					</div>
				</div>
			</div>
		);
	};

	const renderEditorView = () => {
		return (
			<div className="poppit-editor">
				<div className="poppit-header">
					<h4>{ __( 'Poppit', 'poppit' ) }</h4>
					<div className="poppit-meta">
						<span className="popup-type-badge">{ popupType.toUpperCase() }</span>
						<span className="trigger-type-badge">
							{ triggerType === 'time' && __( `After ${triggerDelay}s`, 'poppit' ) }
							{ triggerType === 'scroll' && __( `At ${scrollDepth}%`, 'poppit' ) }
							{ triggerType === 'exit' && __( 'Exit Intent', 'poppit' ) }
							{ triggerType === 'load' && __( 'Page Load', 'poppit' ) }
							{ triggerType === 'manual' && __( 'Manual', 'poppit' ) }
						</span>
						{ allowReset && (
							<span className="reset-badge">{ __( 'RESETS', 'poppit' ) }</span>
						) }
					</div>
				</div>
				
				<div className="poppit-preview-container">
					{ renderPopupPreview() }
				</div>
			</div>
		);
	};

	return (
		<>
			<BlockControls>
				<ToolbarGroup>
					<ToolbarButton
						label={ previewMode ? __( 'Edit Mode', 'poppit' ) : __( 'Preview Mode', 'poppit' ) }
						onClick={ () => setPreviewMode( ! previewMode ) }
						isPressed={ previewMode }
					>
						{ previewMode ? '⚙️' : '👁️' }
					</ToolbarButton>
				</ToolbarGroup>
			</BlockControls>

			<InspectorControls>
				<PanelBody title={ __( 'Pop-up Settings', 'poppit' ) } initialOpen={ true }>
					<SelectControl
						label={ __( 'Pop-up Type', 'poppit' ) }
						value={ popupType }
						options={ popupTypeOptions }
						onChange={ ( value ) => setAttributes( { popupType: value } ) }
					/>
					
					<SelectControl
						label={ __( 'Animation', 'poppit' ) }
						value={ animation }
						options={ animationOptions }
						onChange={ ( value ) => setAttributes( { animation: value } ) }
					/>
					
					{ popupType === 'modal' && (
						<SelectControl
							label={ __( 'Position', 'poppit' ) }
							value={ position }
							options={ positionOptions }
							onChange={ ( value ) => setAttributes( { position: value } ) }
						/>
					) }
					
					<TextControl
						label={ __( 'Width', 'poppit' ) }
						value={ width }
						onChange={ ( value ) => setAttributes( { width: value } ) }
						help={ __( 'e.g., 500px, 80%, auto', 'poppit' ) }
					/>
					
					<ToggleControl
						label={ __( 'Show Close Button', 'poppit' ) }
						checked={ showCloseButton }
						onChange={ ( value ) => setAttributes( { showCloseButton: value } ) }
					/>
					
					<RangeControl
						label={ __( 'Overlay Opacity', 'poppit' ) }
						value={ overlayOpacity }
						onChange={ ( value ) => setAttributes( { overlayOpacity: value } ) }
						min={ 0 }
						max={ 1 }
						step={ 0.1 }
					/>
				</PanelBody>

				<PanelBody title={ __( 'Trigger Settings', 'poppit' ) } initialOpen={ false }>
					<SelectControl
						label={ __( 'Trigger Type', 'poppit' ) }
						value={ triggerType }
						options={ triggerTypeOptions }
						onChange={ ( value ) => setAttributes( { triggerType: value } ) }
					/>
					
					{ triggerType === 'time' && (
						<RangeControl
							label={ __( 'Delay (seconds)', 'poppit' ) }
							value={ triggerDelay }
							onChange={ ( value ) => setAttributes( { triggerDelay: value } ) }
							min={ 0 }
							max={ 60 }
							step={ 1 }
						/>
					) }
					
					{ triggerType === 'scroll' && (
						<RangeControl
							label={ __( 'Scroll Depth (%)', 'poppit' ) }
							value={ scrollDepth }
							onChange={ ( value ) => setAttributes( { scrollDepth: value } ) }
							min={ 0 }
							max={ 100 }
							step={ 5 }
						/>
					) }
					
					{ triggerType === 'exit' && (
						<ToggleControl
							label={ __( 'Enable Exit Intent', 'poppit' ) }
							checked={ exitIntent }
							onChange={ ( value ) => setAttributes( { exitIntent: value } ) }
							help={ __( 'Show popup when user moves cursor to leave the page', 'poppit' ) }
						/>
					) }
				</PanelBody>

				<PanelBody title={ __( 'Reset Behavior', 'poppit' ) } initialOpen={ false }>
					<ToggleControl
						label={ __( 'Allow Reset', 'poppit' ) }
						checked={ allowReset }
						onChange={ ( value ) => setAttributes( { allowReset: value } ) }
						help={ __( 'Allow the popup to be shown again after a specified delay', 'poppit' ) }
					/>
					
					{ allowReset && (
						<>
							<RangeControl
								label={ __( 'Reset Delay (minutes)', 'poppit' ) }
								value={ resetDelay || 60 }
								onChange={ ( value ) => setAttributes( { resetDelay: value } ) }
								min={ 1 }
								max={ 1440 }
								step={ 1 }
								help={ __( 'Time in minutes before the popup can be shown again', 'poppit' ) }
							/>
							
							<div style={{ marginTop: '15px', padding: '12px', backgroundColor: '#f0f6fc', border: '1px solid #c3e4f7', borderRadius: '4px', fontSize: '13px' }}>
								<strong>{ __( 'Testing Options:', 'poppit' ) }</strong>
								<p style={{ margin: '5px 0 0 0', lineHeight: '1.4' }}>{ __( 'Add ?poppit-test=1 to your URL to ignore all display restrictions for testing.', 'poppit' ) }</p>
							</div>
						</>
					) }
				</PanelBody>

				<PanelBody title={ __( 'Email Integration', 'poppit' ) } initialOpen={ false }>
					<ToggleControl
						label={ __( 'Enable Email Collection', 'poppit' ) }
						checked={ emailEnabled }
						onChange={ ( value ) => setAttributes( { emailEnabled: value } ) }
					/>
					
					{ emailEnabled && (
						<>
							<TextControl
								label={ __( 'Email Placeholder', 'poppit' ) }
								value={ emailPlaceholder }
								onChange={ ( value ) => setAttributes( { emailPlaceholder: value } ) }
							/>
							
							<TextControl
								label={ __( 'Button Text', 'poppit' ) }
								value={ buttonText }
								onChange={ ( value ) => setAttributes( { buttonText: value } ) }
							/>
						</>
					) }
				</PanelBody>

				<PanelBody title={ __( 'Targeting Options', 'poppit' ) } initialOpen={ false }>
					<h4>{ __( 'Device Targeting', 'poppit' ) }</h4>
					<CheckboxControl
						label={ __( 'Desktop', 'poppit' ) }
						checked={ targeting.devices.includes( 'desktop' ) }
						onChange={ ( checked ) => {
							const devices = checked 
								? [ ...targeting.devices, 'desktop' ]
								: targeting.devices.filter( d => d !== 'desktop' );
							setAttributes( { targeting: { ...targeting, devices } } );
						} }
					/>
					<CheckboxControl
						label={ __( 'Tablet', 'poppit' ) }
						checked={ targeting.devices.includes( 'tablet' ) }
						onChange={ ( checked ) => {
							const devices = checked 
								? [ ...targeting.devices, 'tablet' ]
								: targeting.devices.filter( d => d !== 'tablet' );
							setAttributes( { targeting: { ...targeting, devices } } );
						} }
					/>
					<CheckboxControl
						label={ __( 'Mobile', 'poppit' ) }
						checked={ targeting.devices.includes( 'mobile' ) }
						onChange={ ( checked ) => {
							const devices = checked 
								? [ ...targeting.devices, 'mobile' ]
								: targeting.devices.filter( d => d !== 'mobile' );
							setAttributes( { targeting: { ...targeting, devices } } );
						} }
					/>
					
					<SelectControl
						label={ __( 'User Type', 'poppit' ) }
						value={ targeting.userType }
						options={ [
							{ label: __( 'All Visitors', 'poppit' ), value: 'all' },
							{ label: __( 'New Visitors', 'poppit' ), value: 'new' },
							{ label: __( 'Returning Visitors', 'poppit' ), value: 'returning' }
						] }
						onChange={ ( value ) => setAttributes( { targeting: { ...targeting, userType: value } } ) }
					/>
				</PanelBody>

				<PanelBody title={ __( 'More Blocks by iconick', 'poppit' ) } initialOpen={ false }>
					<p>
						{ __( 'Think these ideas are wild? You ain\'t seen nothing yet.', 'poppit' ) }
					</p>
					<ExternalLink href="https://iconick.io/blocks/">
						{ __( 'Click to enter the block wonderland', 'poppit' ) }
					</ExternalLink>
				</PanelBody>
			</InspectorControls>

			<div { ...blockProps }>
				{ previewMode ? renderPopupPreview() : renderEditorView() }
			</div>
		</>
	);
}]]></content>
  </file>
  <file path="src/save.js">
    <description>This file contains the save function for the block which is responsible for creating the static result of rendering the block on the client to display the saved result on the front end.</description>
    <content><![CDATA[
	]]></content>
  </file>
  <file path="src/style.scss">
    <description>This file contains styles for the block in the front end.</description>
    <content><![CDATA[/**
 * Frontend styles for the Poppit block
 */

:root {
	--popup-z-index: 999999;
	--popup-border-radius: 8px;
	--popup-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
	--popup-animation-duration: 0.3s;
	--popup-close-size: 32px;
}

/* Base overlay styles */
.popup-overlay {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.8);
	z-index: var(--popup-z-index);
	display: flex;
	align-items: center;
	justify-content: center;
	opacity: 0;
	visibility: hidden;
	transition: opacity var(--popup-animation-duration) ease, visibility var(--popup-animation-duration) ease;
}

.popup-overlay.popup-active {
	opacity: 1;
	visibility: visible;
}

/* Base popup container */
.popup-container {
	background: #fff;
	border-radius: var(--popup-border-radius);
	box-shadow: var(--popup-shadow);
	position: relative;
	max-width: 90vw;
	max-height: 90vh;
	overflow: auto;
	transform: scale(0.8) translateY(20px);
	transition: transform var(--popup-animation-duration) ease;
}

.popup-active .popup-container {
	transform: scale(1) translateY(0);
}

/* Popup type variations */
.popup-modal {
	width: var(--popup-width, 500px);
	height: var(--popup-height, auto);
	margin: 20px;
}

.popup-slide {
	position: fixed;
	width: 350px;
	height: auto;
	transform: translateX(100%);
}

.popup-slide.position-top-right {
	top: 20px;
	right: 20px;
}

.popup-slide.position-top-left {
	top: 20px;
	left: 20px;
	transform: translateX(-100%);
}

.popup-slide.position-bottom-right {
	bottom: 20px;
	right: 20px;
}

.popup-slide.position-bottom-left {
	bottom: 20px;
	left: 20px;
	transform: translateX(-100%);
}

.popup-active .popup-slide {
	transform: translateX(0);
}

.popup-topbar,
.popup-bottombar {
	position: fixed;
	width: 100%;
	left: 0;
	height: auto;
	border-radius: 0;
	margin: 0;
}

.popup-topbar {
	top: 0;
	transform: translateY(-100%);
}

.popup-active .popup-topbar {
	transform: translateY(0);
}

.popup-bottombar {
	bottom: 0;
	transform: translateY(100%);
}

.popup-active .popup-bottombar {
	transform: translateY(0);
}

.popup-fullscreen {
	width: 100vw;
	height: 100vh;
	max-width: none;
	max-height: none;
	border-radius: 0;
	margin: 0;
}

/* Close button */
.popup-close {
	position: absolute;
	top: 10px;
	right: 10px;
	width: var(--popup-close-size);
	height: var(--popup-close-size);
	background: rgba(0, 0, 0, 0.1);
	border: none;
	border-radius: 50%;
	font-size: 20px;
	line-height: 1;
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
	transition: background-color 0.2s ease;
	z-index: 1;
}

.popup-close:hover {
	background: rgba(0, 0, 0, 0.2);
}

.popup-close:focus {
	outline: 2px solid #0073aa;
	outline-offset: 2px;
}

/* Content area */
.popup-content {
	padding: 30px;
}

.popup-topbar .popup-content,
.popup-bottombar .popup-content {
	padding: 15px 30px;
	text-align: center;
}

.popup-title {
	margin: 0 0 15px;
	font-size: 24px;
	font-weight: 600;
	line-height: 1.3;
}

.popup-topbar .popup-title,
.popup-bottombar .popup-title {
	font-size: 18px;
	margin: 0 0 10px;
}

.popup-text {
	margin: 0 0 20px;
	line-height: 1.5;
	color: #666;
}

.popup-topbar .popup-text,
.popup-bottombar .popup-text {
	margin: 0 0 15px;
	font-size: 14px;
}

.popup-text p:last-child {
	margin-bottom: 0;
}

/* Email form */
.popup-email-form {
	display: flex;
	gap: 10px;
	margin-top: 20px;
}

.popup-topbar .popup-email-form,
.popup-bottombar .popup-email-form {
	max-width: 400px;
	margin: 15px auto 0;
}

.popup-email-input {
	flex: 1;
	padding: 12px 15px;
	border: 2px solid #ddd;
	border-radius: 4px;
	font-size: 16px;
	transition: border-color 0.2s ease;
}

.popup-email-input:focus {
	outline: none;
	border-color: #0073aa;
}

.popup-topbar .popup-email-input,
.popup-bottombar .popup-email-input {
	padding: 8px 12px;
	font-size: 14px;
}

.popup-submit-btn {
	padding: 12px 24px;
	background: #0073aa;
	color: #fff;
	border: none;
	border-radius: 4px;
	font-size: 16px;
	font-weight: 600;
	cursor: pointer;
	transition: background-color 0.2s ease;
	white-space: nowrap;
}

.popup-submit-btn:hover {
	background: #005a87;
}

.popup-submit-btn:focus {
	outline: 2px solid #0073aa;
	outline-offset: 2px;
}

.popup-topbar .popup-submit-btn,
.popup-bottombar .popup-submit-btn {
	padding: 8px 16px;
	font-size: 14px;
}

/* Success and error messages */
.popup-success {
	padding: 15px;
	background: #d4edda;
	border: 1px solid #c3e6cb;
	color: #155724;
	border-radius: 4px;
	text-align: center;
	font-weight: 600;
}

.popup-error {
	padding: 10px;
	background: #f8d7da;
	border: 1px solid #f5c6cb;
	color: #721c24;
	border-radius: 4px;
	font-size: 14px;
	margin-top: 10px;
}

/* Animation classes */
.animation-fadeIn .popup-overlay {
	animation: popupFadeIn var(--popup-animation-duration) ease;
}

.animation-slideDown .popup-container {
	transform: translateY(-50px);
}

.popup-active.animation-slideDown .popup-container {
	transform: translateY(0);
}

.animation-slideUp .popup-container {
	transform: translateY(50px);
}

.popup-active.animation-slideUp .popup-container {
	transform: translateY(0);
}

.animation-zoomIn .popup-container {
	transform: scale(0.5);
}

.popup-active.animation-zoomIn .popup-container {
	transform: scale(1);
}

.animation-bounceIn .popup-container {
	animation: popupBounceIn var(--popup-animation-duration) ease;
}

/* Keyframes */
@keyframes popupFadeIn {
	from {
		opacity: 0;
	}
	to {
		opacity: 1;
	}
}

@keyframes popupBounceIn {
	0% {
		transform: scale(0.3);
		opacity: 0;
	}
	50% {
		transform: scale(1.05);
	}
	70% {
		transform: scale(0.9);
	}
	100% {
		transform: scale(1);
		opacity: 1;
	}
}

/* Mobile responsiveness */
@media (max-width: 768px) {
	.popup-container {
		margin: 10px;
		max-width: calc(100vw - 20px);
	}

	.popup-modal {
		width: 100%;
		max-width: none;
	}

	.popup-slide {
		width: calc(100vw - 40px);
		left: 20px;
		right: 20px;
	}

	.popup-slide.position-top-right,
	.popup-slide.position-top-left {
		transform: translateY(-100%);
	}

	.popup-slide.position-bottom-right,
	.popup-slide.position-bottom-left {
		transform: translateY(100%);
	}

	.popup-active .popup-slide {
		transform: translateY(0);
	}

	.popup-content {
		padding: 20px;
	}

	.popup-title {
		font-size: 20px;
	}

	.popup-close {
		top: 8px;
		right: 8px;
		width: 28px;
		height: 28px;
		font-size: 18px;
	}

	.popup-email-form {
		flex-direction: column;
		gap: 10px;
	}
}

/* Editor-specific styles */
.wp-block-telex-block-poppit .popup-overlay {
	position: relative;
	width: 100%;
	height: auto;
	background: transparent;
	z-index: auto;
	opacity: 1;
	visibility: visible;
}

/* High contrast mode support */
@media (prefers-contrast: high) {
	.popup-container {
		border: 2px solid #000;
	}
	
	.popup-close {
		background: #000;
		color: #fff;
	}
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
	.popup-overlay,
	.popup-container {
		transition: none;
		animation: none;
	}

	.popup-container {
		transform: none;
	}

	.popup-active .popup-container {
		transform: none;
	}
}]]></content>
  </file>
  <file path="src/editor.scss">
    <description>This file contains styles for the block in the editor.</description>
    <content><![CDATA[/**
 * Editor styles for the Advanced Pop-up Maker block
 */

.wp-block-telex-block-poppit {
	border: 2px dashed #ccc;
	border-radius: 8px;
	padding: 0;
	margin: 20px 0;
	min-height: 200px;
	background: #f9f9f9;

	&:hover {
		border-color: #0073aa;
	}

	&.is-selected {
		border-color: #0073aa;
		border-style: solid;
		box-shadow: 0 0 0 2px rgba(0, 115, 170, 0.3);
	}
}

// Editor preview styles
.poppit-editor {
	padding: 20px;

	.poppit-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		margin-bottom: 20px;
		padding-bottom: 15px;
		border-bottom: 1px solid #e0e0e0;

		h4 {
			margin: 0;
			font-size: 18px;
			color: #1e1e1e;
		}

		.poppit-meta {
			display: flex;
			gap: 10px;
		}

		.popup-type-badge,
		.trigger-type-badge,
		.reset-badge {
			padding: 4px 8px;
			border-radius: 4px;
			font-size: 11px;
			font-weight: 600;
			text-transform: uppercase;
			letter-spacing: 0.5px;
		}

		.popup-type-badge {
			background: #0073aa;
			color: #fff;
		}

		.trigger-type-badge {
			background: #00a32a;
			color: #fff;
		}

		.reset-badge {
			background: #d63638;
			color: #fff;
		}
	}

	.poppit-preview-container {
		background: #fff;
		border: 1px solid #e0e0e0;
		border-radius: 6px;
		padding: 20px;
		margin-bottom: 20px;
		position: relative;
		overflow: hidden;
	}

	.poppit-info {
		padding: 15px;
		background: #f0f6fc;
		border: 1px solid #c3e4f7;
		border-radius: 6px;
		font-size: 14px;
		line-height: 1.5;
		color: #0c4a6e;

		p {
			margin: 0;
		}
	}
}

// Preview mode styles
.poppit-preview {
	.popup-overlay {
		position: relative;
		background: rgba(0, 0, 0, 0.1);
		min-height: 300px;
		border-radius: 6px;
		display: flex;
		align-items: center;
		justify-content: center;
		opacity: 1;
		visibility: visible;
	}

	.popup-container {
		position: relative;
		max-width: 400px;
		width: 100%;
		transform: none;
		box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
		background: #fff;
		border-radius: 8px;
		padding: 0;
		overflow: hidden;

		&.popup-topbar,
		&.popup-bottombar {
			max-width: 100%;
			width: 100%;
			border-radius: 6px;
		}

		&.popup-slide {
			max-width: 280px;
		}

		&.popup-fullscreen {
			max-width: 100%;
			width: 100%;
			height: 200px;
			max-height: none;
		}
	}

	.popup-content {
		padding: 25px;

		.popup-topbar &,
		.popup-bottombar & {
			padding: 15px 25px;
			text-align: center;
		}

		.popup-fullscreen & {
			padding: 40px 25px;
			text-align: center;
		}
	}

	.popup-title {
		margin: 0 0 12px;
		font-size: 20px;
		font-weight: 600;
		color: #1e1e1e;
		line-height: 1.3;

		&[contenteditable="true"] {
			outline: none;
			border: 1px dashed transparent;
			border-radius: 3px;
			padding: 2px;

			&:focus {
				border-color: #0073aa;
				background: rgba(0, 115, 170, 0.05);
			}
		}

		.popup-topbar &,
		.popup-bottombar & {
			font-size: 16px;
		}
	}

	.popup-text {
		margin: 0 0 15px;
		color: #666;
		line-height: 1.5;
		font-size: 14px;

		&[contenteditable="true"] {
			outline: none;
			border: 1px dashed transparent;
			border-radius: 3px;
			padding: 2px;

			&:focus {
				border-color: #0073aa;
				background: rgba(0, 115, 170, 0.05);
			}
		}

		.popup-topbar &,
		.popup-bottombar & {
			margin: 0 0 10px;
			font-size: 13px;
		}
	}

	.popup-close {
		position: absolute;
		top: 8px;
		right: 8px;
		width: 28px;
		height: 28px;
		background: rgba(0, 0, 0, 0.1);
		border: none;
		border-radius: 50%;
		cursor: pointer;
		display: flex;
		align-items: center;
		justify-content: center;
		font-size: 16px;
		color: #666;
		transition: background-color 0.2s ease;

		&:hover {
			background: rgba(0, 0, 0, 0.2);
		}
	}

	.popup-email-form {
		display: flex;
		gap: 8px;
		margin-top: 15px;

		.popup-topbar &,
		.popup-bottombar & {
			max-width: 300px;
			margin: 10px auto 0;
		}
	}

	.popup-email-input {
		flex: 1;
		padding: 10px 12px;
		border: 2px solid #e0e0e0;
		border-radius: 4px;
		font-size: 14px;
		background: #fff;

		&::placeholder {
			color: #999;
		}
	}

	.popup-submit-btn {
		padding: 10px 18px;
		background: #0073aa;
		color: #fff;
		border: none;
		border-radius: 4px;
		font-size: 14px;
		font-weight: 600;
		cursor: pointer;
		white-space: nowrap;
	}
}

// Inspector panel custom styles
.poppit-inspector {
	.components-panel__body-toggle {
		font-weight: 600;
	}

	.components-base-control__help {
		font-size: 12px;
		font-style: italic;
		color: #757575;
		margin-top: 8px;
	}
}

// Block toolbar styles
.block-editor-block-toolbar .poppit-toolbar {
	.components-toolbar-button {
		&.is-pressed {
			background: #0073aa;
			color: #fff;
		}
	}
}

// Responsive preview
@media (max-width: 768px) {
	.poppit-preview {
		.popup-container {
			max-width: 300px;
			margin: 10px;
		}

		.popup-content {
			padding: 20px;
		}

		.popup-email-form {
			flex-direction: column;
			gap: 8px;
		}
	}

	.poppit-editor {
		.poppit-header {
			flex-direction: column;
			align-items: flex-start;
			gap: 10px;

			.poppit-meta {
				align-self: stretch;
				justify-content: flex-start;
			}
		}
	}
}

// Dark mode support
.is-dark-theme {
	.poppit-editor {
		background: #1e1e1e;
		color: #fff;

		.poppit-header {
			border-bottom-color: #3c3c3c;

			h4 {
				color: #fff;
			}
		}

		.poppit-preview-container {
			background: #2c2c2c;
			border-color: #3c3c3c;
		}

		.poppit-info {
			background: #2c2c2c;
			border-color: #3c3c3c;
			color: #e0e0e0;
		}
	}
}]]></content>
  </file>
  <file path="src/view.js">
    <description>This file contains the view function for the block which is responsible for rendering interactive behaviors of the block on the front end. Ideally using the WordPress interactivity API.</description>
    <content><![CDATA[/**
 * Frontend JavaScript for Poppit
 * Handles popup triggers, display logic, and user interactions
 * Security-focused implementation with proper error handling
 */

class Poppit {
	constructor() {
		this.popups = [];
		this.isReady = false;
		this.visitorType = this.getVisitorType();
		this.deviceType = this.getDeviceType();
		this.triggeredPopups = new Set();
		this.scrollDepths = new Map();
		this.timers = new Map();
		this.sessionShownPopups = new Set();
		this.debugMode = this.getUrlParam('poppit-debug') === '1';
		this.testMode = this.getUrlParam('poppit-test') === '1';
		this.rateLimits = new Map(); // Rate limiting for API calls
		
		this.init();
	}

	init() {
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', () => this.onReady());
		} else {
			this.onReady();
		}
	}

	onReady() {
		this.debug('Poppit initialized');
		this.isReady = true;
		this.findPopups();
		this.setupEventListeners();
		// Small delay to ensure all DOM elements are ready
		setTimeout(() => {
			this.processPopups();
		}, 100);
	}

	findPopups() {
		try {
			const popupBlocks = document.querySelectorAll('[data-popup-id]');
			this.debug(`Found ${popupBlocks.length} popup blocks`);
			
			popupBlocks.forEach((block, index) => {
				const popupData = this.extractPopupData(block);
				if (popupData && this.shouldShowPopup(popupData)) {
					this.popups.push(popupData);
					this.debug(`Added popup ${popupData.id} to queue (${index + 1}/${popupBlocks.length})`);
				} else {
					this.debug(`Skipped popup ${popupData?.id || 'unknown'} due to targeting rules or previous display`);
				}
			});
			
			this.debug(`Total popups in queue: ${this.popups.length}`);
		} catch (error) {
			console.error('Error finding popups:', error);
		}
	}

	extractPopupData(block) {
		try {
			const data = {
				id: this.sanitizeString(block.dataset.popupId || ''),
				type: this.sanitizeString(block.dataset.popupType || 'modal'),
				triggerType: this.sanitizeString(block.dataset.triggerType || 'time'),
				triggerDelay: this.sanitizeNumber(block.dataset.triggerDelay, 3, 0, 300),
				scrollDepth: this.sanitizeNumber(block.dataset.scrollDepth, 50, 0, 100),
				exitIntent: block.dataset.exitIntent === 'true',
				targeting: this.parseJSON(block.dataset.targeting, {devices:['desktop','tablet','mobile'],userType:'all'}),
				allowReset: block.dataset.allowReset === 'true',
				resetDelay: this.sanitizeNumber(block.dataset.resetDelay, 60, 1, 10080), // Max 1 week
				element: block,
				shown: false,
				timestamp: Date.now()
			};
			
			// Validate required ID
			if (!data.id || data.id.length > 50) {
				this.debug('Invalid or missing popup ID');
				return null;
			}
			
			return data;
		} catch (error) {
			console.warn('Error parsing popup data:', error);
			return null;
		}
	}

	// Utility functions for data sanitization
	sanitizeString(str, maxLength = 100) {
		if (typeof str !== 'string') return '';
		return str.trim().substring(0, maxLength);
	}

	sanitizeNumber(value, defaultValue = 0, min = 0, max = Number.MAX_SAFE_INTEGER) {
		const num = parseInt(value, 10);
		if (isNaN(num)) return defaultValue;
		return Math.min(Math.max(num, min), max);
	}

	parseJSON(jsonStr, defaultValue = {}) {
		try {
			if (!jsonStr) return defaultValue;
			const parsed = JSON.parse(jsonStr);
			return typeof parsed === 'object' && parsed !== null ? parsed : defaultValue;
		} catch (error) {
			return defaultValue;
		}
	}

	getUrlParam(param) {
		const urlParams = new URLSearchParams(window.location.search);
		return urlParams.get(param);
	}

	shouldShowPopup(popup) {
		try {
			// Check device targeting
			if (!popup.targeting.devices.includes(this.deviceType)) {
				this.debug(`Popup ${popup.id} filtered out by device targeting`);
				return false;
			}

			// Check visitor type targeting
			if (popup.targeting.userType !== 'all' && popup.targeting.userType !== this.visitorType) {
				this.debug(`Popup ${popup.id} filtered out by visitor type targeting`);
				return false;
			}

			// In test mode, always show popups
			if (this.testMode) {
				this.debug(`Test mode enabled - popup ${popup.id} will be shown`);
				return true;
			}

			// Check if popup was already shown in current session
			if (this.sessionShownPopups.has(popup.id)) {
				this.debug(`Popup ${popup.id} already shown in current session`);
				return false;
			}

			// Check if popup was already shown with reset logic
			return this.checkPopupResetStatus(popup);
		} catch (error) {
			console.error('Error in shouldShowPopup:', error);
			return false;
		}
	}

	checkPopupResetStatus(popup) {
		try {
			const storageKey = `poppit_${popup.id}`;
			const storedData = localStorage.getItem(storageKey);
			
			if (!storedData) {
				this.debug(`Popup ${popup.id} never shown before`);
				return true;
			}
			
			const data = this.parseJSON(storedData);
			if (!data.lastShown) return true;
			
			const lastShown = new Date(data.lastShown);
			const now = new Date();
			
			// If reset is not allowed, never show again
			if (!popup.allowReset) {
				this.debug(`Popup ${popup.id} already shown and reset not allowed`);
				return false;
			}
			
			// Calculate time since last shown
			const minutesSinceLastShown = (now - lastShown) / (1000 * 60);
			const resetDelayMinutes = popup.resetDelay;
			
			if (minutesSinceLastShown >= resetDelayMinutes) {
				this.debug(`Popup ${popup.id} reset period expired (${Math.round(minutesSinceLastShown)}/${resetDelayMinutes} minutes)`);
				return true;
			} else {
				this.debug(`Popup ${popup.id} still in reset cooldown (${Math.round(minutesSinceLastShown)}/${resetDelayMinutes} minutes)`);
				return false;
			}
		} catch (error) {
			console.warn('Error parsing popup reset data:', error);
			return true;
		}
	}

	processPopups() {
		try {
			this.debug('Processing popup triggers...');
			
			this.popups.forEach(popup => {
				this.debug(`Setting up trigger for popup ${popup.id}: ${popup.triggerType}`);
				
				// Clear any existing setup for this popup
				this.clearPopupTriggers(popup.id);
				
				switch (popup.triggerType) {
					case 'time':
						this.setupTimeBasedTrigger(popup);
						break;
					case 'scroll':
						this.setupScrollTrigger(popup);
						break;
					case 'exit':
						this.setupExitIntentTrigger(popup);
						break;
					case 'load':
						// Add small delay even for immediate triggers
						setTimeout(() => this.showPopup(popup), 100);
						break;
				}
			});
		} catch (error) {
			console.error('Error processing popups:', error);
		}
	}

	clearPopupTriggers(popupId) {
		// Clear any existing timer
		if (this.timers.has(popupId)) {
			clearTimeout(this.timers.get(popupId));
			this.timers.delete(popupId);
			this.debug(`Cleared existing timer for popup ${popupId}`);
		}
		
		// Remove from triggered set
		this.triggeredPopups.delete(popupId);
		
		// Clear scroll depth tracking
		this.scrollDepths.delete(popupId);
	}

	setupTimeBasedTrigger(popup) {
		const delay = Math.max(popup.triggerDelay * 1000, 100);
		this.debug(`Setting timer for popup ${popup.id}: ${delay}ms`);
		
		const timerId = setTimeout(() => {
			this.debug(`Timer fired for popup ${popup.id}`);
			if (!this.triggeredPopups.has(popup.id)) {
				this.showPopup(popup);
			}
			this.timers.delete(popup.id);
		}, delay);
		
		this.timers.set(popup.id, timerId);
	}

	setupScrollTrigger(popup) {
		this.scrollDepths.set(popup.id, {
			popup,
			targetDepth: popup.scrollDepth,
			triggered: false
		});
		this.debug(`Scroll trigger set for popup ${popup.id} at ${popup.scrollDepth}%`);
	}

	setupExitIntentTrigger(popup) {
		let exitIntentFired = false;
		
		const handleMouseLeave = (e) => {
			if (exitIntentFired || this.triggeredPopups.has(popup.id)) return;
			
			if (e.clientY <= 0 || (e.relatedTarget === null && e.target === document.documentElement)) {
				exitIntentFired = true;
				this.debug(`Exit intent triggered for popup ${popup.id}`);
				this.showPopup(popup);
				document.removeEventListener('mouseleave', handleMouseLeave);
				document.removeEventListener('mousemove', handleMouseMove);
			}
		};

		let lastMouseY = 0;
		const handleMouseMove = (e) => {
			if (exitIntentFired || this.triggeredPopups.has(popup.id)) return;
			
			if (e.clientY < 100 && lastMouseY > e.clientY + 50) {
				exitIntentFired = true;
				this.debug(`Exit intent triggered via mouse movement for popup ${popup.id}`);
				this.showPopup(popup);
				document.removeEventListener('mouseleave', handleMouseLeave);
				document.removeEventListener('mousemove', handleMouseMove);
			}
			lastMouseY = e.clientY;
		};

		document.addEventListener('mouseleave', handleMouseLeave);
		document.addEventListener('mousemove', handleMouseMove);
	}

	setupEventListeners() {
		try {
			// Scroll listener with debouncing
			let scrollTimeout;
			window.addEventListener('scroll', () => {
				clearTimeout(scrollTimeout);
				scrollTimeout = setTimeout(() => {
					this.handleScroll();
				}, 100);
			}, { passive: true });

			// Close popup listeners
			document.addEventListener('click', (e) => {
				if (e.target && (e.target.classList.contains('popup-close') || 
					(e.target.classList.contains('popup-overlay') && e.target === e.currentTarget))) {
					e.preventDefault();
					this.closePopup(e.target.closest('.popup-overlay'));
				}
			});

			// Escape key listener
			document.addEventListener('keydown', (e) => {
				if (e.key === 'Escape') {
					this.closeAllPopups();
				}
			});

			// Form submission listener
			document.addEventListener('submit', (e) => {
				if (e.target && e.target.classList.contains('popup-email-form')) {
					e.preventDefault();
					this.handleEmailSubmission(e.target);
				}
			});
		} catch (error) {
			console.error('Error setting up event listeners:', error);
		}
	}

	handleScroll() {
		try {
			const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
			const scrollHeight = document.body.scrollHeight - window.innerHeight;
			const scrollPercent = scrollHeight > 0 ? (scrollTop / scrollHeight) * 100 : 0;
			
			this.scrollDepths.forEach((data, popupId) => {
				if (!data.triggered && !this.triggeredPopups.has(popupId) && scrollPercent >= data.targetDepth) {
					data.triggered = true;
					this.debug(`Scroll trigger activated for popup ${popupId} at ${Math.round(scrollPercent)}%`);
					this.showPopup(data.popup);
					this.scrollDepths.delete(popupId);
				}
			});
		} catch (error) {
			console.error('Error in scroll handler:', error);
		}
	}

	showPopup(popup) {
		try {
			if (popup.shown || this.triggeredPopups.has(popup.id)) {
				this.debug(`Popup ${popup.id} already shown or triggered`);
				return;
			}

			this.debug(`Showing popup ${popup.id}`);
			this.triggeredPopups.add(popup.id);
			this.sessionShownPopups.add(popup.id);
			popup.shown = true;

			// Clear any pending timer for this popup
			if (this.timers.has(popup.id)) {
				clearTimeout(this.timers.get(popup.id));
				this.timers.delete(popup.id);
			}

			// Create popup HTML
			const popupHTML = this.createPopupHTML(popup);
			document.body.insertAdjacentHTML('beforeend', popupHTML);

			// Trigger animation
			const overlay = document.getElementById(`popup-${popup.id}`);
			if (overlay) {
				overlay.offsetHeight; // Force reflow
				requestAnimationFrame(() => {
					overlay.classList.add('popup-active');
				});
			}

			// Track display event
			this.trackEvent(popup.id, 'display');

			// Store in localStorage (only in non-test mode)
			if (!this.testMode) {
				try {
					const storageKey = `poppit_${popup.id}`;
					const data = {
						lastShown: new Date().toISOString(),
						showCount: this.getShowCount(popup.id) + 1
					};
					localStorage.setItem(storageKey, JSON.stringify(data));
				} catch (storageError) {
					console.warn('Failed to save popup data to localStorage:', storageError);
				}
			}
		} catch (error) {
			console.error('Error showing popup:', error);
		}
	}

	getShowCount(popupId) {
		try {
			const storageKey = `poppit_${popupId}`;
			const storedData = localStorage.getItem(storageKey);
			
			if (storedData) {
				const data = this.parseJSON(storedData);
				return data.showCount || 0;
			}
		} catch (error) {
			console.warn('Error getting show count:', error);
		}
		
		return 0;
	}

	createPopupHTML(popup) {
		try {
			const element = popup.element;
			if (!element) return '';
			
			// Sanitize content from DOM
			const titleEl = element.querySelector('.popup-title');
			const contentEl = element.querySelector('.popup-text');
			
			const title = titleEl ? this.sanitizeHTML(titleEl.innerHTML) : '';
			const content = contentEl ? this.sanitizeHTML(contentEl.innerHTML) : '';
			
			// Get sanitized attributes
			const emailEnabled = element.dataset.emailEnabled === 'true';
			const emailPlaceholder = this.sanitizeString(element.dataset.emailPlaceholder || 'Enter your email', 100);
			const buttonText = this.sanitizeString(element.dataset.buttonText || 'Subscribe', 50);
			const showCloseButton = element.dataset.showCloseButton !== 'false';
			const overlayOpacity = this.sanitizeNumber(element.dataset.overlayOpacity * 100, 80, 0, 100) / 100;
			const animation = this.sanitizeString(element.dataset.animation || 'fadeIn', 20);

			return `
				<div class="popup-overlay animation-${animation}" id="popup-${popup.id}" style="background: rgba(0, 0, 0, ${overlayOpacity})">
					<div class="popup-container popup-${popup.type}" role="dialog" aria-modal="true" aria-labelledby="popup-title-${popup.id}">
						${showCloseButton ? `<button class="popup-close" aria-label="Close popup">×</button>` : ''}
						<div class="popup-content">
							${title ? `<h3 class="popup-title" id="popup-title-${popup.id}">${title}</h3>` : ''}
							${content ? `<div class="popup-text">${content}</div>` : ''}
							${emailEnabled ? `
								<form class="popup-email-form" data-popup-id="${popup.id}" novalidate>
									<input type="email" class="popup-email-input" placeholder="${emailPlaceholder}" required autocomplete="email" maxlength="254">
									<button type="submit" class="popup-submit-btn">${buttonText}</button>
								</form>
							` : ''}
						</div>
					</div>
				</div>
			`;
		} catch (error) {
			console.error('Error creating popup HTML:', error);
			return '';
		}
	}

	// Basic HTML sanitization (for display content only)
	sanitizeHTML(html) {
		const div = document.createElement('div');
		div.textContent = html;
		return div.innerHTML;
	}

	closePopup(overlay) {
		try {
			if (!overlay) return;

			overlay.classList.remove('popup-active');
			
			setTimeout(() => {
				if (overlay.parentNode) {
					overlay.remove();
				}
			}, 300);

			const popupId = overlay.id.replace('popup-', '');
			if (popupId) {
				this.trackEvent(popupId, 'close');
				this.debug(`Popup ${popupId} closed`);
			}
		} catch (error) {
			console.error('Error closing popup:', error);
		}
	}

	closeAllPopups() {
		try {
			const activePopups = document.querySelectorAll('.popup-overlay.popup-active');
			activePopups.forEach(popup => this.closePopup(popup));
			this.debug(`Closed ${activePopups.length} active popups`);
		} catch (error) {
			console.error('Error closing all popups:', error);
		}
	}

	handleEmailSubmission(form) {
		try {
			const emailInput = form.querySelector('input[type="email"]');
			const submitBtn = form.querySelector('.popup-submit-btn');
			const popupId = this.sanitizeString(form.dataset.popupId || '');
			
			if (!emailInput || !submitBtn || !popupId) {
				console.error('Missing form elements or popup ID');
				return;
			}
			
			const email = emailInput.value.trim();
			
			// Client-side email validation
			if (!this.isValidEmail(email)) {
				this.showFormError(form, 'Please enter a valid email address.');
				return;
			}
			
			// Rate limiting check
			if (this.isRateLimited('email', popupId)) {
				this.showFormError(form, 'Please wait before submitting again.');
				return;
			}
			
			// Disable button and show loading state
			const originalText = submitBtn.textContent;
			submitBtn.disabled = true;
			submitBtn.textContent = 'Submitting...';
			
			// Clear any existing errors
			this.clearFormError(form);

			// Submit email
			if (typeof poppitAjax !== 'undefined' && poppitAjax.ajaxurl) {
				const formData = new FormData();
				formData.append('action', 'poppit_email');
				formData.append('nonce', poppitAjax.nonce);
				formData.append('email', email);
				formData.append('popup_id', popupId);
				formData.append('page_url', window.location.href);
				
				fetch(poppitAjax.ajaxurl, {
					method: 'POST',
					body: formData,
					credentials: 'same-origin'
				})
				.then(response => {
					if (!response.ok) {
						throw new Error(`HTTP error! status: ${response.status}`);
					}
					return response.json();
				})
				.then(data => {
					if (data && data.success) {
						// Show success message
						form.innerHTML = '<div class="popup-success">Thank you for subscribing!</div>';
						this.trackEvent(popupId, 'email_submit');
						
						// Auto-close after success
						setTimeout(() => {
							this.closePopup(document.getElementById(`popup-${popupId}`));
						}, 2000);
					} else {
						throw new Error(data?.data || 'Submission failed');
					}
				})
				.catch(error => {
					console.error('Email submission error:', error);
					submitBtn.disabled = false;
					submitBtn.textContent = originalText;
					
					this.showFormError(form, 'Something went wrong. Please try again.');
				});
			} else {
				// Fallback if AJAX is not available
				console.log('Email submitted (fallback):', email);
				form.innerHTML = '<div class="popup-success">Thank you for subscribing!</div>';
				setTimeout(() => {
					this.closePopup(document.getElementById(`popup-${popupId}`));
				}, 2000);
			}
		} catch (error) {
			console.error('Error in email submission handler:', error);
		}
	}

	// Email validation
	isValidEmail(email) {
		const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
		return emailRegex.test(email) && email.length <= 254;
	}

	// Rate limiting
	isRateLimited(action, identifier) {
		const key = `${action}_${identifier}`;
		const now = Date.now();
		const limit = this.rateLimits.get(key);
		
		if (limit && (now - limit.lastAction) < limit.cooldown) {
			return true;
		}
		
		this.rateLimits.set(key, {
			lastAction: now,
			cooldown: 2000 // 2 second cooldown
		});
		
		return false;
	}

	showFormError(form, message) {
		this.clearFormError(form);
		const errorDiv = document.createElement('div');
		errorDiv.className = 'popup-error';
		errorDiv.textContent = message;
		form.appendChild(errorDiv);
	}

	clearFormError(form) {
		const existingError = form.querySelector('.popup-error');
		if (existingError) {
			existingError.remove();
		}
	}

	trackEvent(popupId, eventType) {
		try {
			if (typeof poppitAjax !== 'undefined' && poppitAjax.ajaxurl) {
				// Rate limiting for tracking calls
				if (this.isRateLimited('track', popupId)) {
					return;
				}
				
				const formData = new FormData();
				formData.append('action', 'poppit_track');
				formData.append('nonce', poppitAjax.nonce);
				formData.append('popup_id', popupId);
				formData.append('event_type', eventType);
				formData.append('page_url', window.location.href);
				
				fetch(poppitAjax.ajaxurl, {
					method: 'POST',
					body: formData,
					credentials: 'same-origin'
				}).catch(error => {
					console.warn('Analytics tracking failed:', error);
				});
			}
		} catch (error) {
			console.warn('Error in trackEvent:', error);
		}
	}

	debug(message) {
		if (this.debugMode) {
			console.log(`[Poppit Debug] ${message}`);
		}
	}

	getVisitorType() {
		try {
			const visited = localStorage.getItem('poppit_visited');
			if (visited) {
				return 'returning';
			} else {
				localStorage.setItem('poppit_visited', 'true');
				return 'new';
			}
		} catch (error) {
			// Fallback if localStorage is not available
			return 'new';
		}
	}

	getDeviceType() {
		const width = window.innerWidth;
		if (width <= 768) return 'mobile';
		if (width <= 1024) return 'tablet';
		return 'desktop';
	}

	// Utility methods for debugging (only available in debug/test mode)
	resetPopupDisplay(popupId) {
		if (!this.testMode && !this.debugMode) {
			console.warn('Reset methods only available in test or debug mode');
			return;
		}
		
		try {
			if (popupId) {
				const storageKey = `poppit_${popupId}`;
				localStorage.removeItem(storageKey);
				this.sessionShownPopups.delete(popupId);
				this.triggeredPopups.delete(popupId);
				this.clearPopupTriggers(popupId);
				this.debug(`Reset display status for popup ${popupId}`);
			} else {
				// Reset all popups
				const keys = [];
				for (let i = 0; i < localStorage.length; i++) {
					const key = localStorage.key(i);
					if (key && key.startsWith('poppit_')) {
						keys.push(key);
					}
				}
				keys.forEach(key => localStorage.removeItem(key));
				
				this.sessionShownPopups.clear();
				this.triggeredPopups.clear();
				
				this.timers.forEach((timerId) => {
					clearTimeout(timerId);
				});
				this.timers.clear();
				this.scrollDepths.clear();
				
				this.debug('Reset all popup display statuses');
			}
		} catch (error) {
			console.error('Error resetting popup display:', error);
		}
	}

	reprocessPopups() {
		if (!this.testMode && !this.debugMode) {
			console.warn('Reprocess method only available in test or debug mode');
			return;
		}
		
		try {
			this.debug('Reprocessing popups...');
			this.popups = [];
			this.findPopups();
			this.processPopups();
		} catch (error) {
			console.error('Error reprocessing popups:', error);
		}
	}

	getPopupStatus(popupId) {
		if (!this.testMode && !this.debugMode) {
			console.warn('Status method only available in test or debug mode');
			return null;
		}
		
		try {
			const storageKey = `poppit_${popupId}`;
			const storedData = localStorage.getItem(storageKey);
			
			const status = {
				popupId: popupId,
				shownInSession: this.sessionShownPopups.has(popupId),
				triggered: this.triggeredPopups.has(popupId),
				hasActiveTimer: this.timers.has(popupId),
				storedData: null,
				canShow: false
			};
			
			if (storedData) {
				status.storedData = this.parseJSON(storedData);
				if (status.storedData.lastShown) {
					const lastShown = new Date(status.storedData.lastShown);
					const minutesSince = (new Date() - lastShown) / (1000 * 60);
					status.minutesSinceLastShown = Math.round(minutesSince);
				}
			}
			
			const popupElement = document.querySelector(`[data-popup-id="${popupId}"]`);
			if (popupElement) {
				const popup = this.extractPopupData(popupElement);
				if (popup) {
					status.canShow = this.shouldShowPopup(popup);
					status.allowReset = popup.allowReset;
					status.resetDelay = popup.resetDelay;
				}
			}
			
			return status;
		} catch (error) {
			console.error('Error getting popup status:', error);
			return null;
		}
	}
}

// Initialize when DOM is ready
try {
	const poppitInstance = new Poppit();

	// Expose instance to global scope for debugging and testing
	if (poppitInstance.debugMode || poppitInstance.testMode) {
		window.Poppit = poppitInstance;
		console.log('Poppit debug mode enabled. Use window.Poppit to access the instance.');
		console.log('Available methods:');
		console.log('- resetPopupDisplay(popupId) - Reset display status for specific popup or all popups');
		console.log('- reprocessPopups() - Re-scan and setup all popup triggers');
		console.log('- getPopupStatus(popupId) - Get detailed status information for a popup');
		console.log('URL parameters:');
		console.log('- ?poppit-debug=1 (debug mode with console logs)');
		console.log('- ?poppit-test=1 (test mode - ignores localStorage restrictions)');
	}
} catch (error) {
	console.error('Failed to initialize Poppit:', error);
}]]></content>
  </file>
  <file path="src/render.php">
    <description>This file contains the render callback function for the block, which is responsible for rendering the block content on the front end. A render function should exist only if the block is dynamic.</description>
    <content><![CDATA[<?php
/**
 * Render callback for the Poppit block
 * Implements proper security practices and data validation
 *
 * @param array    $attributes Block attributes
 * @param string   $content    Block content
 * @param WP_Block $block      Block object
 * 
 * @return string The block HTML
 */

// Security: Ensure we're in a WordPress context
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

// Validate and sanitize all attributes with proper defaults
$popup_id = ! empty( $attributes['popupId'] ) ? sanitize_key( $attributes['popupId'] ) : 'popup-' . wp_generate_uuid4();
$popup_type = ! empty( $attributes['popupType'] ) ? sanitize_key( $attributes['popupType'] ) : 'modal';
$title = ! empty( $attributes['title'] ) ? wp_kses_post( $attributes['title'] ) : '';
$content_text = ! empty( $attributes['content'] ) ? wp_kses_post( $attributes['content'] ) : '';
$trigger_type = ! empty( $attributes['triggerType'] ) ? sanitize_key( $attributes['triggerType'] ) : 'time';
$trigger_delay = isset( $attributes['triggerDelay'] ) ? absint( $attributes['triggerDelay'] ) : 3;
$scroll_depth = isset( $attributes['scrollDepth'] ) ? min( max( absint( $attributes['scrollDepth'] ), 0 ), 100 ) : 50;
$exit_intent = ! empty( $attributes['exitIntent'] ) && $attributes['exitIntent'];
$show_close_button = ! isset( $attributes['showCloseButton'] ) || $attributes['showCloseButton'];
$overlay_opacity = isset( $attributes['overlayOpacity'] ) ? min( max( floatval( $attributes['overlayOpacity'] ), 0 ), 1 ) : 0.8;
$email_enabled = ! empty( $attributes['emailEnabled'] ) && $attributes['emailEnabled'];
$email_placeholder = ! empty( $attributes['emailPlaceholder'] ) ? sanitize_text_field( $attributes['emailPlaceholder'] ) : __( 'Enter your email address', 'poppit' );
$button_text = ! empty( $attributes['buttonText'] ) ? sanitize_text_field( $attributes['buttonText'] ) : __( 'Subscribe', 'poppit' );
$animation = ! empty( $attributes['animation'] ) ? sanitize_key( $attributes['animation'] ) : 'fadeIn';
$width = ! empty( $attributes['width'] ) ? sanitize_text_field( $attributes['width'] ) : '500px';
$height = ! empty( $attributes['height'] ) ? sanitize_text_field( $attributes['height'] ) : 'auto';
$position = ! empty( $attributes['position'] ) ? sanitize_key( $attributes['position'] ) : 'center';
$allow_reset = ! empty( $attributes['allowReset'] ) && $attributes['allowReset'];
$reset_delay = isset( $attributes['resetDelay'] ) ? min( max( absint( $attributes['resetDelay'] ), 1 ), 10080 ) : 60; // Max 1 week

// Validate targeting data with proper defaults
$targeting_defaults = [
	'devices' => [ 'desktop', 'tablet', 'mobile' ],
	'userType' => 'all'
];

$targeting = $targeting_defaults;
if ( ! empty( $attributes['targeting'] ) && is_array( $attributes['targeting'] ) ) {
	// Validate devices array
	if ( isset( $attributes['targeting']['devices'] ) && is_array( $attributes['targeting']['devices'] ) ) {
		$valid_devices = [ 'desktop', 'tablet', 'mobile' ];
		$targeting['devices'] = array_intersect( $attributes['targeting']['devices'], $valid_devices );
		// Ensure at least one device is selected
		if ( empty( $targeting['devices'] ) ) {
			$targeting['devices'] = $targeting_defaults['devices'];
		}
	}
	
	// Validate user type
	if ( isset( $attributes['targeting']['userType'] ) ) {
		$valid_user_types = [ 'all', 'new', 'returning' ];
		if ( in_array( $attributes['targeting']['userType'], $valid_user_types, true ) ) {
			$targeting['userType'] = $attributes['targeting']['userType'];
		}
	}
}

// Validate popup and trigger types against allowed values
$valid_popup_types = [ 'modal', 'slide', 'topbar', 'bottombar', 'fullscreen' ];
if ( ! in_array( $popup_type, $valid_popup_types, true ) ) {
	$popup_type = 'modal';
}

$valid_trigger_types = [ 'time', 'scroll', 'exit', 'load', 'manual' ];
if ( ! in_array( $trigger_type, $valid_trigger_types, true ) ) {
	$trigger_type = 'time';
}

$valid_animations = [ 'fadeIn', 'slideDown', 'slideUp', 'zoomIn', 'bounceIn' ];
if ( ! in_array( $animation, $valid_animations, true ) ) {
	$animation = 'fadeIn';
}

$valid_positions = [ 'center', 'top-left', 'top-right', 'bottom-left', 'bottom-right' ];
if ( ! in_array( $position, $valid_positions, true ) ) {
	$position = 'center';
}

// Sanitize width and height values to prevent CSS injection
$width = preg_match( '/^[0-9]+(px|%|em|rem|vw|vh|auto)$/i', $width ) ? $width : '500px';
$height = preg_match( '/^[0-9]+(px|%|em|rem|vw|vh|auto)$/i', $height ) ? $height : 'auto';

// Security: Limit popup ID length and ensure it's safe
if ( strlen( $popup_id ) > 50 ) {
	$popup_id = substr( $popup_id, 0, 50 );
}

// Security: Limit text field lengths to prevent abuse
$email_placeholder = substr( $email_placeholder, 0, 100 );
$button_text = substr( $button_text, 0, 50 );

// Build safe CSS custom properties
$css_vars = sprintf(
	'--popup-width: %s; --popup-height: %s;',
	esc_attr( $width ),
	esc_attr( $height )
);

// Prepare data attributes with proper escaping
$data_attributes = [
	'data-popup-id' => esc_attr( $popup_id ),
	'data-popup-type' => esc_attr( $popup_type ),
	'data-trigger-type' => esc_attr( $trigger_type ),
	'data-trigger-delay' => esc_attr( $trigger_delay ),
	'data-scroll-depth' => esc_attr( $scroll_depth ),
	'data-exit-intent' => $exit_intent ? 'true' : 'false',
	'data-show-close-button' => $show_close_button ? 'true' : 'false',
	'data-overlay-opacity' => esc_attr( $overlay_opacity ),
	'data-email-enabled' => $email_enabled ? 'true' : 'false',
	'data-email-placeholder' => esc_attr( $email_placeholder ),
	'data-button-text' => esc_attr( $button_text ),
	'data-targeting' => esc_attr( wp_json_encode( $targeting, JSON_UNESCAPED_SLASHES ) ),
	'data-animation' => esc_attr( $animation ),
	'data-width' => esc_attr( $width ),
	'data-height' => esc_attr( $height ),
	'data-position' => esc_attr( $position ),
	'data-allow-reset' => $allow_reset ? 'true' : 'false',
	'data-reset-delay' => esc_attr( $reset_delay )
];

// Get block wrapper attributes with proper escaping
$wrapper_attributes = get_block_wrapper_attributes( [
	'class' => 'poppit-block',
	'style' => $css_vars
] + $data_attributes );

// Prepare JSON data for the JavaScript (double-encoded for security)
$popup_data = [
	'id' => $popup_id,
	'type' => $popup_type,
	'title' => $title,
	'content' => $content_text,
	'triggerType' => $trigger_type,
	'triggerDelay' => $trigger_delay,
	'scrollDepth' => $scroll_depth,
	'exitIntent' => $exit_intent,
	'showCloseButton' => $show_close_button,
	'overlayOpacity' => $overlay_opacity,
	'emailEnabled' => $email_enabled,
	'emailPlaceholder' => $email_placeholder,
	'buttonText' => $button_text,
	'targeting' => $targeting,
	'animation' => $animation,
	'width' => $width,
	'height' => $height,
	'position' => $position,
	'allowReset' => $allow_reset,
	'resetDelay' => $reset_delay,
	'nonce' => wp_create_nonce( 'poppit_view_' . $popup_id ) // Add view-specific nonce
];

// Start output buffering for clean HTML
ob_start();
?>

<div <?php echo wp_kses_post( $wrapper_attributes ); ?>>
	<?php if ( ! empty( $title ) ) : ?>
		<div class="popup-title" style="display: none;"><?php echo wp_kses_post( $title ); ?></div>
	<?php endif; ?>
	
	<?php if ( ! empty( $content_text ) ) : ?>
		<div class="popup-text" style="display: none;"><?php echo wp_kses_post( $content_text ); ?></div>
	<?php endif; ?>
	
	<!-- Popup configuration data for JavaScript -->
	<script type="application/json" class="popup-data">
		<?php echo wp_json_encode( $popup_data, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE ); ?>
	</script>
</div>

<?php
// Return the buffered output
return ob_get_clean();]]></content>
  </file>
  <file path="package.json">
    <description>The AI assistant should only edit 'user_provided_block_name_slug', 'description' and resolve 'isDynamicVariant' in this file and ALWAYS INCLUDE IT. This file includes the necessary scripts for building, formatting, and linting the block code. Dependencies are managed at the workspace level via pnpm.</description>
    <content><![CDATA[{
    "name": "poppit",
    "version": "0.1.0",
    "description": "Build pop-ups that feel like helpful suggestions, not annoying interruptions",
    "author": "WordPress Telex",
    "license": "GPL-2.0-or-later",
    "main": "build/index.js",
    "scripts": {
        "build": "wp-scripts build --webpack-copy-php",
        "format": "wp-scripts format",
        "lint:css": "wp-scripts lint-style",
        "lint:js": "wp-scripts lint-js",
        "packages-update": "wp-scripts packages-update",
        "plugin-zip": "wp-scripts plugin-zip",
        "start": "wp-scripts start --blocks-manifest"
    }
}]]></content>
  </file>
</artefact>
